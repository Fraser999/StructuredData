<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `structured_data` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, structured_data">

    <title>structured_data - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'structured_data', ty: 'mod', relpath: '../'};</script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>structured_data</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-0' class='srclink' href='../src/structured_data/main.rs.html#1-173' title='goto source code'>[src]</a></span></h1>
<div class='docblock'>
<h1 id="example-of-proposed-structured-data-for-the-safe-network" class='section-header'><a
                           href="#example-of-proposed-structured-data-for-the-safe-network">Example of Proposed Structured Data for the SAFE Network</a></h1>
<p>This is an extension of the proposed implementation described in <a href="https://github.com/maidsafe/rfcs/pull/11/files" title="SAFE Network RFC 0000">RFC 0000</a>.  It conflicts
with the &quot;Detailed Design&quot; section, but is in alignment with the other main sections of the RFC.</p>

<p>It may be helpful to view the raw source either <a href="https://github.com/Fraser999/StructuredData/blob/master/src/structured_data.rs" title="Raw source for Structured Data on GitHub">on GitHub</a> or <a href="http://fraser999.github.io/StructuredData/src/structured_data/structured_data.rs.html" title="Raw source for Structured Data in the docs">in the docs</a> while reading
this, since it shows all the elements together in one place.</p>

<p>The main differences between the original proposal and this are:</p>

<ul>
<li>Clearly-identified immutable and mutable parts</li>
<li>Multiple versions retained in a single place</li>
<li>No signatures retained in the <code>Data</code> element</li>
</ul>

<p>This proposal is slightly more complex than the original, but not largely so.  This added
complexity provides greater ease of use and extensibility of rules.</p>

<h1 id="authorisation-of-mutating-requests" class='section-header'><a
                           href="#authorisation-of-mutating-requests">Authorisation of Mutating Requests</a></h1>
<p>This is more flexible than the process described in the original proposal.  The idea is that
each owners&#39; public key is given a weighting.  To authorise a mutation, enough signatures must
be provided so that the combined weight of the corresponding public keys exceeds a limit.  The
limit can itself be changed via an authorised request.</p>

<p>This basic system works well for a single owner (where the calculation is almost a no-op), but
also is fairly simple to understand in the case of multiple owners.  The rules for the network
to implement this are as simple as in the original proposal, and the cost in terms of data size
is minimal; a <code>u64</code> plus another <code>u64</code> per owner.  For a single owner, both of these elements
could be removed from the serialised <code>Data</code>, giving no additional cost.</p>

<p>I have also not included the signatures as part of the <code>Data</code> since these only need to be
examined by the network at the point when the <code>Data</code> is mutated, i.e. when the request is
received.  This may be an oversight though, in which case they can be added where required.</p>

<h1 id="immutable-part-of-data" class='section-header'><a
                           href="#immutable-part-of-data">Immutable Part of <code>Data</code></a></h1>
<p>The <code>FixedAttributes</code> are immutable for the lifetime of the <code>Data</code>.  As well as the original
<code>type_tag</code> and <code>id</code> whose meanings are unchanged, I have added the following fields:</p>

<ul>
<li><code>max_versions</code>: self-explanatory, but the rules for handling exceeding this limit would need
to be decided.  An easy option would be to simply pop the oldest version.</li>
<li><code>min_retained_count</code>: we can archive old versions if required.  The process would need to be
defined, but these archived parts could become immutable and hence even stored as
<code>ImmutableData</code>.  At the point when the old versions are stripped out of the <code>Data</code> for
archiving, this field would specify how many versions to retain.  This could be just one if the
data type in question normally only needs the single most recent version (e.g. user&#39;s session
packet) or could be many if the data often uses several versions (e.g. file browser with
rollback capabilities).</li>
<li><code>data</code>: This can be used for any purpose appropriate to that particular <code>Data</code> type.</li>
</ul>

<h1 id="mutable-part-of-data" class='section-header'><a
                           href="#mutable-part-of-data">Mutable Part of <code>Data</code></a></h1>
<p>The <code>MutableAttributes</code> can be changed if enough owners sign a request to change them.  Such a
request would need to also come with an incremented <code>Version</code> to avoid synchronisation issues.</p>

<p>The <code>owner_keys</code> and <code>min_weight_for_consensus</code> relate to the authorisation process described
above.  The remaining fields are:</p>

<ul>
<li><code>expiry_date</code>: a (probably controversial!) idea to allow the <code>Data</code> to be removed from the
network on a given date.  This would not require exactness or an NTP server - it would be an
approximate time point at which the the managing nodes would remove the <code>Data</code> from their
records.  This isn&#39;t just to save space on the network, more that it could be a useful feature
for users.</li>
<li><code>data</code>: as per <code>FixedAttributes::data</code>.</li>
</ul>

<h1 id="versions" class='section-header'><a
                           href="#versions">Versions</a></h1>
<p>Another major departure from the original proposal is to hold a <code>Vec&lt;Version&gt;</code> rather than a
single one.  This would comprise the most recent versions, but may be only one if
<code>FixedAttributes::max_versions == 1</code> or may be all versions if total <code>Data</code> size permits.</p>

<p>In at least two of our own use-cases (session packet and directory listings), we need to be able
to store and retrieve more than just the most recent version.  This can be done in the original
proposal by serialising this information into the single <code>data</code> field, but this proposal makes
that task more obvious and less error-prone.</p>

<p>Furthermore, by exposing the versions in this way, it leaves scope for the network to be able to
handle archiving old versions without any client interaction.  This wouldn&#39;t be possible if the
 network weren&#39;t able to access the list of versions, as is the case in the original proposal.</p>

<p>The <code>Version</code> struct comprises two elements:</p>

<ul>
<li><code>index</code>: This will be an incrementing value.  To maintain simplicity we can enforce a strict
increment-by-one policy, i.e. if a new version arrives out of sequence it will be rejected.
However, this isn&#39;t an issue as long as the client has to send the entire <code>Data</code> every time a
mutation is made.  We can look at re-implementing the branching protocol as per the
<code>StructuredDataVersions</code> from the C++ codebase, but I don&#39;t think that was a popular class.</li>
<li><code>data</code>: per-version arbitrary data.</li>
</ul>

<h1 id="general" class='section-header'><a
                           href="#general">General</a></h1>
<p>There would still be a hard upper limit on the total size of a <code>Data</code> instance as described in
the original proposal.</p>

<p>While some of the rules can be ignored in the initial implementation of this (e.g. handling
archiving) I don&#39;t envisage this being more difficult to implement than the original proposal.
This also leaves room for eventual improvement in efficiency, for example by allowing clients to
send only a new <code>Version</code> rather than always sending a full <code>Data</code> packet.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='mod' href='structured_data/index.html'
                               title='structured_data::structured_data'>structured_data</a></td>
                        <td class='docblock short'>
                             <p>Structured Data implementation.</p>

                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
            <p>
                Search functions by type signature (e.g.
                <code>vec -> usize</code>)
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "structured_data";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>